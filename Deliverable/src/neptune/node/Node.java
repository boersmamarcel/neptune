package neptune.node;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;

import neptune.NeptuneException;
import neptune.assembly.Program;

/**
 * Abstract class that is used as the base of all other nodes.
 * 
 * @author Koen van Urk and Marcel Boersma
 */
public abstract class Node {

	/**
	 * Enum that defines all types of the Neptune language.
	 * 
	 * @author Koen van Urk and Marcel Boersma
	 */
	public enum type {
		VOID, INTEGER, CHAR, BOOL
	}
	
	/**
	 * List that stores children of the Node
	 */
	protected List<Node> children = new ArrayList<Node>();
	
	/**
	 * Stores a type for the node.
	 * 
	 * NOTE: use getType() to retrieve the actual type of a Node.
	 */
	protected type primitive = type.VOID;
	
	/**
	 * Stores whether or not the element is an array.
	 * 
	 *  NOTE: use isArray() to retrieve the actual value for a Node.
	 */
	protected boolean isArray = false;
	
	/**
	 * Stores whether or not the element is mutable.
	 * 
	 *  NOTE: use isMutable() to retrieve the actual value for a Node.
	 */
	protected boolean isMutable = false;
	
	/**
	 * Stores whether or not a result that can be generated by a node is used by a parent. 
	 */
	protected boolean resultIsUsed = false;
	
	/**
	 * Stores whether the number of elements for an array.
	 * 
	 *  NOTE: use elemCount() to retrieve the actual elements count for an array Node.
	 */
	protected int elemCount = 0;
	
	/**
	 * Description for a node (printed in exceptions for example)
	 */
	public String description;
	
	/* (non-Javadoc)
	 * @see java.lang.Object#toString()
	 */
	public String toString() {
		return description + " ( " + children.toString() + " ) ";
	}
	
	/**
	 * Method that validates the Node and its children. Each non-abstract node will implement custom logic here.
	 * 
	 * @param p A program containing a symbol table.
	 * @throws NeptuneException Thrown in case of validation errors.
	 */
	public abstract void validate(Program p) throws NeptuneException;
	
	/**
	 * Method that generates assembly instructions for the Node and its children. Each non-abstract node will implement custom logic here.
	 * 
	 * @param p A program containing a symbol table and store for instructions.
	 * @param info Key value storage used to pass on additional instructions from parent to child.
	 * @throws NeptuneException Thrown in case of symbol table errors.
	 */
	public abstract void generate(Program p, Map<String, Object> info) throws NeptuneException;
	
	/**
	 * Matches a nodes type against another node using the typing rules of the Neptune language.
	 * 
	 * @param node Node to check type against.
	 * @return true if type is equal according to the Neptune language rules, false otherwise.
	 */
	public boolean typeMatch(Node node) {
		
		boolean eType = node.getType() == this.getType();
		boolean eArray = node.isArray() == this.isArray();
		boolean eCount = node.elemCount() == this.elemCount();
		boolean intOrChar = (node.getType() == type.INTEGER && this.getType() == type.CHAR);
		boolean charOrInt = (node.getType() == type.CHAR && this.getType() == type.INTEGER);
		
		return (eType || intOrChar || charOrInt) && eArray && eCount;
	}
	
	/**
	 * Retrieve the actual primitive type of a Node.
	 * 
	 * @return Primitive type.
	 */
	public abstract type getType();
	
	/**
	 * Retrieve the actual value for whether or not this Node is an array.
	 * 
	 * @return true if element is an array, false otherwise.
	 */
	public abstract boolean isArray();
	
	/**
	 * Retrieve the actual value for whether or not this Node is mutable.
	 * 
	 * @return true if element is mutable, false otherwise.
	 */
	public abstract boolean isMutable();
	
	/**
	 * The number of elements contained in this Node. Only provides useful information when isArray() returns true.
	 * 
	 * @return Number of elements.
	 */
	public abstract int elemCount();
	
	/**
	 * Returns a string describing the type of this Node. Useful for debugging and providing error messages.
	 * 
	 * @return A string describing the type of this Node.
	 */
	public String typeDescription() {
		if(isArray()) {
			return getType() + "[" + elemCount() + "]";
		}else{
			return "" + getType();
		}
	}
	
}
